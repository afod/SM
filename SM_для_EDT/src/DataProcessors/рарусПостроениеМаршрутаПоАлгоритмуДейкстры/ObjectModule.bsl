
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ПрограммныйИнтерфейс

//
//https://its.1c.ru/db/bsp244doc#content:31:1
Функция СведенияОВнешнейОбработке() Экспорт
	
	ПараметрыРегистрации = Новый Структура;	
	ПараметрыРегистрации.Вставить("Вид"     , ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиДополнительнаяОбработка());
	МассивНазначений = Новый Массив;
	ПараметрыРегистрации.Вставить("Назначение"     , МассивНазначений);
	ПараметрыРегистрации.Вставить("Наименование"   , ЭтотОбъект.Метаданные().Синоним);
	КомментарийОбработки = ЭтотОбъект.Метаданные().Комментарий;
	ПозицияНезначащихСимволов = Найти(КомментарийОбработки,"//");
	Если ПозицияНезначащихСимволов <> 0 Тогда
		КомментарийОбработки = СокрЛП(Лев(КомментарийОбработки,ПозицияНезначащихСимволов - 1));
	Иначе
		КомментарийОбработки = СокрЛП(КомментарийОбработки);
	КонецЕсли;
	ПараметрыРегистрации.Вставить("Версия"         ,"1.0");
	ПараметрыРегистрации.Вставить("БезопасныйРежим", ЛОЖЬ);
	ПараметрыРегистрации.Вставить("Информация"     , ЭтотОбъект.Метаданные().Синоним);
	ПараметрыРегистрации.Вставить("ОпределитьНастройкиФормы"      , Ложь);
	ТаблицаКоманд = Новый ТаблицаЗначений;
	ТаблицаКоманд.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка"));
	ТаблицаКоманд.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Строка"));
	ТаблицаКоманд.Колонки.Добавить("Использование", Новый ОписаниеТипов("Строка"));
	ТаблицаКоманд.Колонки.Добавить("ПоказыватьОповещение", Новый ОписаниеТипов("Булево"));
	ТаблицаКоманд.Колонки.Добавить("Модификатор", Новый ОписаниеТипов("Строка"));
	ТаблицаКоманд.Колонки.Добавить("Скрыть",      Новый ОписаниеТипов("Булево"));
	ТаблицаКоманд.Колонки.Добавить("ЗаменяемыеКоманды", Новый ОписаниеТипов("Строка"));
	
	Команда = ТаблицаКоманд.Добавить();
	Команда.Представление = ЭтотОбъект.Метаданные().Синоним;
	Команда.Идентификатор = ЭтотОбъект.Метаданные().Имя;
	Команда.Использование = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыОткрытиеФормы();
	Команда.ПоказыватьОповещение = Истина;
	Команда.Модификатор = "";
	
	ПараметрыРегистрации.Вставить("Команды", ТаблицаКоманд);
	Возврат ПараметрыРегистрации;
	
КонецФункции//СведенияОВнешнейОбработке()

&НаСервере
Процедура АлгоритмПостроенияНаСервере(ПунктОправления, ПунктСледования, Судно, ТипСостава, ДатаПостроенияМаршрута = Неопределено) Экспорт
	// ++ rarus Камаев П.В. 13.03.2020 добавлен параметр "ТипСостава" Задача № 20339	
	ТекДата1 = ТекущаяДата();
	ТЗ_ПунктыДляСледующегоЭтапа.Очистить();
	ТаблицаИерархииПунктовДляМаршрута.Очистить();
	
	МинимальноеРасстояниеПоПостроеннымМаршрутам = Неопределено;
	
	#Область ПодготовкаДанных
	
	//При поиске маршрута используется алгоритм Дейкстры, с возможностью дальнейшего преобразования в алгоритм A*
	
	//Общая часть
	
	Если ДатаПостроенияМаршрута = Неопределено Тогда
		ДатаПостроенияМаршрута = ТекущаяДата();
	КонецЕсли;
	
	
	// Отбор только необходимых норм следования
	// Добавить отбор по судну, если нет по судну, то берем по Проекту
	Проект = Судно.Проект;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	рарусАктуальныеНормыСледованияПоПроектамСудовСрезПоследних.ПунктОтправления КАК ПунктОтправления,
	|	рарусАктуальныеНормыСледованияПоПроектамСудовСрезПоследних.ПунктСледования КАК ПунктСледования,
	|	рарусАктуальныеНормыСледованияПоПроектамСудовСрезПоследних.Расстояние КАК Расстояние
	|ПОМЕСТИТЬ ВТ_ПунктыПоПроекту
	|ИЗ
	|	РегистрСведений.рарусАктуальныеНормыСледованияПоПроектамСудов.СрезПоследних(&ДатаПостроенияМаршрута, ПроектСудна = &ПроектСудна) КАК рарусАктуальныеНормыСледованияПоПроектамСудовСрезПоследних
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	рарусАктуальныеНормыСледованияПоПроектамСудовСрезПоследних.ПунктОтправления КАК ПунктОтправления,
	|	рарусАктуальныеНормыСледованияПоПроектамСудовСрезПоследних.ПунктСледования КАК ПунктСледования,
	|	рарусАктуальныеНормыСледованияПоПроектамСудовСрезПоследних.Расстояние КАК Расстояние
	|ПОМЕСТИТЬ ВТ_АктуальныеПунктыПоПустомуПроекту
	|ИЗ
	|	РегистрСведений.рарусАктуальныеНормыСледованияПоПроектамСудов.СрезПоследних(&ДатаПостроенияМаршрута, ПроектСудна = &ПустойПроектСудна) КАК рарусАктуальныеНормыСледованияПоПроектамСудовСрезПоследних
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_АктуальныеПунктыПоПустомуПроекту.ПунктОтправления КАК ПунктОтправления,
	|	ВТ_АктуальныеПунктыПоПустомуПроекту.ПунктСледования КАК ПунктСледования,
	|	ВТ_АктуальныеПунктыПоПустомуПроекту.Расстояние КАК Расстояние,
	|	ВЫБОР
	|		КОГДА ВТ_ПунктыПоПроекту.Расстояние ЕСТЬ NULL
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ КАК ОставляемНорму
	|ПОМЕСТИТЬ ВТ_ДополнительныеГеографическиеРасстояния
	|ИЗ
	|	ВТ_АктуальныеПунктыПоПустомуПроекту КАК ВТ_АктуальныеПунктыПоПустомуПроекту
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ПунктыПоПроекту КАК ВТ_ПунктыПоПроекту
	|		ПО ВТ_АктуальныеПунктыПоПустомуПроекту.ПунктОтправления = ВТ_ПунктыПоПроекту.ПунктОтправления
	|			И ВТ_АктуальныеПунктыПоПустомуПроекту.ПунктСледования = ВТ_ПунктыПоПроекту.ПунктСледования
	|ГДЕ
	|	ВЫБОР
	|			КОГДА ВТ_ПунктыПоПроекту.Расстояние ЕСТЬ NULL
	|				ТОГДА ИСТИНА
	|			ИНАЧЕ ЛОЖЬ
	|		КОНЕЦ = ИСТИНА
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ПунктыПоПроекту.ПунктОтправления КАК ПунктОтправления,
	|	ВТ_ПунктыПоПроекту.ПунктСледования КАК ПунктСледования,
	|	ВТ_ПунктыПоПроекту.Расстояние КАК Расстояние
	|ИЗ
	|	ВТ_ПунктыПоПроекту КАК ВТ_ПунктыПоПроекту
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	ВТ_ДополнительныеГеографическиеРасстояния.ПунктОтправления,
	|	ВТ_ДополнительныеГеографическиеРасстояния.ПунктСледования,
	|	ВТ_ДополнительныеГеографическиеРасстояния.Расстояние
	|ИЗ
	|	ВТ_ДополнительныеГеографическиеРасстояния КАК ВТ_ДополнительныеГеографическиеРасстояния
	|";
	
	Запрос.УстановитьПараметр("ДатаПостроенияМаршрута", ДатаПостроенияМаршрута);
	// ++ rarus Камаев П.В. 13.03.2020 Задача № 20339
	Если ЗначениеЗаполнено(ТипСостава) Тогда
		Запрос.УстановитьПараметр("ПроектСудна", ТипСостава);
	Иначе
		Запрос.УстановитьПараметр("ПроектСудна", Проект);
	КонецЕсли;
	// -- rarus Камаев П.В. 13.03.2020
	
	Запрос.УстановитьПараметр("ПустойПроектСудна", Справочники.vftПроектыСудов.ПустаяСсылка());
	ТЗ_ПунктыДляСледующегоЭтапа.Загрузить(Запрос.Выполнить().Выгрузить());
	
	// для хранения пунктов, которые не сипользуеются при поиске, т.е. "отработанные" пункты
	//МассивИсключенныхПунктов = Новый Массив; 
	//МассивИсключенныхПунктов.Добавить(ПунктОтправления);
	НайденныеСтроки = ТЗ_ПунктыДляСледующегоЭтапа.НайтиСтроки(новый Структура("ПунктСледования", ПунктОтправления));
	Для каждого НайденнаяСтрока Из НайденныеСтроки Цикл
		ТЗ_ПунктыДляСледующегоЭтапа.Удалить(НайденнаяСтрока);
	КонецЦикла;
	
	//// НЕ ПРЕОБРАЗОВЫВАТЬ В ДЕРЕВО!!! 1С не справляется с Деревом, падает с ошибкой заполненности стека
	//ТаблицаИерархииПунктовДляМаршрута = Новый ТаблицаЗначений;
	//ТаблицаИерархииПунктовДляМаршрута.Колонки.Добавить("НомерСтрокиРодителя");
	//ТаблицаИерархииПунктовДляМаршрута.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число"));
	//ТаблицаИерархииПунктовДляМаршрута.Колонки.Добавить("Пункт", Новый ОписаниеТипов("СправочникСсылка.рарусПунктыСледования"));
	//ТаблицаИерархииПунктовДляМаршрута.Колонки.Добавить("Расстояние",  Новый ОписаниеТипов("Число"));
	////ТаблицаИерархииПунктовДляМаршрута.Колонки.Добавить("РасстояниеДоКонечной",  Новый ОписаниеТипов("Число"));  // расстояние по координатам, Для алгоритма A* , пока не используем
	//
	//ТаблицаИерархииПунктовДляМаршрута.Колонки.Добавить("Тупик"); // Устанавливается Истина, когда от данной точки нет возможности дальнейшего построения маршрута (т.к. МассивИсключенныхПунктов заполняется и ограничивает пути). При Тупик = Истина поле ЯвляетсяГраничным устанавливается в ЛОЖЬ 
	//ТаблицаИерархииПунктовДляМаршрута.Колонки.Добавить("НайденБолееОптимальныйМаршрутКДанномуПункту");  // устанавливается Истина в процедуре ПроверяемНаНаличиеДублейПунктов 
	//ТаблицаИерархииПунктовДляМаршрута.Колонки.Добавить("ЯвляетсяГраничным", Новый ОписаниеТипов("Булево")); // т.е. строка еще НЕ отработана, маршрут строится ТОЛЬКО от граничных
	//ТаблицаИерархииПунктовДляМаршрута.Колонки.Добавить("Построен"); // устанавливается Истина при достижения конечного пункта, при этом ЯвляетсяГраничным устанавливается в Ложь, т.к. от данной точки дальнейшее построение не требуется
	//
	//Если ЯвляетсяГраничным = Истина, то  Тупик, НайденБолееОптимальныйМаршрутКДанномуПункту, Построен = Ложь, и наоборот
	//Но для понимания, почему ветка была отброшена при построении, оставляем все колонки	
	
	#КонецОбласти
	
	
	// Первый пункт
	
	ПерваяВетка = ТаблицаИерархииПунктовДляМаршрута.Добавить();
	ПерваяВетка.НомерСтрокиРодителя = 0;
	мНомерСтроки = 1;
	ПерваяВетка.мНомерСтроки = мНомерСтроки;
	мНомерСтроки = мНомерСтроки + 1;
	
	ПерваяВетка.Пункт = ПунктОтправления;
	ПерваяВетка.Расстояние = 0;
	//ПерваяВетка.РасстояниеДоКонечной = 0; // Будет использовано, если будем строить по алгоритму  "A*". Т.е. при построении будет браться минимум(Расстояние + РасстояниеДоКонечной), сейчас   минимум (Расстояние)
	ПерваяВетка.Тупик = Ложь;
	ПерваяВетка.НайденБолееОптимальныйМаршрутКДанномуПункту = Ложь;
	ПерваяВетка.ЯвляетсяГраничным = Истина;
	
	Если ПерваяВетка.Пункт = ПунктСледования Тогда
		ПерваяВетка.Построен = Истина;
		ПерваяВетка.ЯвляетсяГраничным = Ложь;
	КонецЕсли;
	
	
	
	//При заполнении стека, после определнного количество итераций ТаблицаИерархииПунктовДляМаршрута (отбор ЯвляетсяГраничным = Ложь) записывать в регистр
	// т.о. оставить в ТаблицаИерархииПунктовДляМаршрута только граничные
	//После окончания построения поместить все оставшиеся записи ТаблицаИерархииПунктовДляМаршрута в регистр
	// Для вывода маршрута обращаться к регистру вместо ТаблицаИерархииПунктовДляМаршрута 
	// После вывода регситр очистить (только те записи,которые относятся  к данному построению, т.к. параллельно могут строить другой маршрут) 
	
	//ЦиклПоВетке(МенеджерВременныхТаблиц, ТаблицаИерархииПунктовДляМаршрута, ПерваяВетка, МассивИсключенныхПунктов, НомерСтроки);
	
	Сч = 0;
	Пока Сч = 0 Цикл
		ЦиклПоВетке(ПерваяВетка, мНомерСтроки, Сч);
		Если Сч > 0 Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	//Вывод
	//Если ЗначениеЗаполнено(МинимальноеРасстояниеПоПостроеннымМаршрутам) - значит есть хотя бы один маршрут
	Если ЗначениеЗаполнено(МинимальноеРасстояниеПоПостроеннымМаршрутам) ТОгда
		ЗаполнитьМаршрут();
		ЗаполнитьВспомогательныеДанныеМаршрута();
	КонецЕсли;
	
	ТекДата2 = ТекущаяДата();
	ВремяВыполнения = (ТекДата2 - ТекДата1) / 60;
	
КонецПроцедуры

#КонецОбласти 

#Область СлужебныеПроцедурыИФункции

Процедура ЗаполнитьМаршрут()
	
	ПунктыМаршрута = Новый Массив;
	
	// Ветка с минимальным расстоянием
	ОтборПоМинимальномуРасстоянию = Новый Структура;
	ОтборПоМинимальномуРасстоянию.Вставить("Построен", Истина);
	ОтборПоМинимальномуРасстоянию.Вставить("Расстояние", МинимальноеРасстояниеПоПостроеннымМаршрутам);
	
	Маршрут = ТаблицаИерархииПунктовДляМаршрута.НайтиСтроки(ОтборПоМинимальномуРасстоянию);
	НашМаршрут = Маршрут[0];	
	
	//Записываем все пункты в Массив
	ПунктыМаршрута = Новый Массив;
	ПунктыМаршрута.Добавить(НашМаршрут.Пункт);
	Родитель = НашМаршрут.НомерСтрокиРодителя;
	
	Пока НЕ Родитель = 0 Цикл
		
		ОтборПоНомеру = Новый Структура;
		ОтборПоНомеру.Вставить("мНомерСтроки", Родитель);
		
		Маршрут = ТаблицаИерархииПунктовДляМаршрута.НайтиСтроки(ОтборПоНомеру);
		НашМаршрут = Маршрут[0];
		ПунктыМаршрута.Добавить(НашМаршрут.Пункт);
		Родитель = НашМаршрут.НомерСтрокиРодителя;
	КонецЦикла;
	
	//Переносим Полученные пункты в ТЧ обработки (переворачиваем данные)
	КоличествоПунктов = ПунктыМаршрута.Количество();
	мНомерСтроки = 1;
	Пока мНомерСтроки <= КоличествоПунктов Цикл
		НоваяСтрока = ПунктыПрохождения.Добавить();
		НоваяСтрока.Пункт = ПунктыМаршрута[КоличествоПунктов-мНомерСтроки];
		мНомерСтроки = мНомерСтроки + 1;
	КонецЦикла;
	
	
КонецПроцедуры

Процедура ЗаполнитьВспомогательныеДанныеМаршрута()
	
	// Заполняем водный участок и признак по/против течения
	
	ПунктПредыдущий = Неопределено;
	Для каждого Строка ИЗ  ПунктыПрохождения Цикл
		
		Если Строка.НомерСтроки = 1 ТОгда
			ПунктПредыдущий = Строка.Пункт;
			Продолжить;
		Иначе
			Запрос = Новый Запрос;
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	рарусВодныеУчасткиПунктыСледования.Ссылка КАК ВодныйУчасток,
			|	рарусВодныеУчасткиПунктыСледования.НомерСтроки КАК НомерСтроки
			|ПОМЕСТИТЬ ВТ_ТекущийПункт
			|ИЗ
			|	Справочник.vftВодныеУчастки.ПунктыСледования КАК рарусВодныеУчасткиПунктыСледования
			|ГДЕ
			|	рарусВодныеУчасткиПунктыСледования.Пункт = &ПунктТекущий
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ
			|	рарусВодныеУчасткиПунктыСледования.Ссылка КАК ВодныйУчасток,
			|	рарусВодныеУчасткиПунктыСледования.НомерСтроки КАК НомерСтроки
			|ПОМЕСТИТЬ ВТ_ПредыдущийПункт
			|ИЗ
			|	Справочник.vftВодныеУчастки.ПунктыСледования КАК рарусВодныеУчасткиПунктыСледования
			|ГДЕ
			|	рарусВодныеУчасткиПунктыСледования.Пункт = &ПунктПредыдущий
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ
			|	ВТ_ПредыдущийПункт.ВодныйУчасток КАК ВодныйУчасток,
			|	ВТ_ПредыдущийПункт.НомерСтроки КАК НомерСтрокиПервогоПункта,
			|	ВТ_ТекущийПункт.НомерСтроки КАК НомерСтрокиВторогоПункта
			|ИЗ
			|	ВТ_ТекущийПункт КАК ВТ_ТекущийПункт
			|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТ_ПредыдущийПункт КАК ВТ_ПредыдущийПункт
			|		ПО ВТ_ТекущийПункт.ВодныйУчасток = ВТ_ПредыдущийПункт.ВодныйУчасток";
			
			
			ПунктТекущий = Строка.Пункт;
			
			Запрос.УстановитьПараметр("ПунктПредыдущий", ПунктПредыдущий);
			Запрос.УстановитьПараметр("ПунктТекущий", ПунктТекущий);
			
			РезультатЗапроса = Запрос.Выполнить();
			
			ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
			
			ВыборкаДетальныеЗаписи.Следующий();
			
			Строка.Участок = ВыборкаДетальныеЗаписи.ВодныйУчасток;
			Если ВыборкаДетальныеЗаписи.ВодныйУчасток = Неопределено Тогда
				Строка.ПризнакДвиженияПоТечению = Ложь;
			Иначе
				Строка.ПризнакДвиженияПоТечению = ?(ВыборкаДетальныеЗаписи.ВодныйУчасток.РекаМоре = Перечисления.vftРекаМоре.Море,
				Ложь, ?(ВыборкаДетальныеЗаписи.НомерСтрокиПервогоПункта < ВыборкаДетальныеЗаписи.НомерСтрокиВторогоПункта,
				Истина, Ложь)); 
			КонецЕсли;
			ПунктПредыдущий = ПунктТекущий;
		КОнецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
//Процедура ЦиклПоВетке(МенеджерВременныхТаблиц, ТаблицаИерархииПунктовДляМаршрута, Строка_ТаблицаИерархииПунктовДляМаршрута, МассивИсключенныхПунктов, НомерСтроки)
Процедура ЦиклПоВетке(Строка_ТаблицаИерархииПунктовДляМаршрута, мНомерСтроки, Сч)
	
	Если Сч = 500 Тогда
		Сч = 0;
		Возврат;
	КонецЕсли;
	сч = сч + 1;
	
	//ФормированиеСубВеток(МенеджерВременныхТаблиц, ТаблицаИерархииПунктовДляМаршрута, 
	//Строка_ТаблицаИерархииПунктовДляМаршрута, МассивИсключенныхПунктов, НомерСтроки);
	
	ФормированиеСубВеток(Строка_ТаблицаИерархииПунктовДляМаршрута, мНомерСтроки);
	
	ТаблицаИерархииПунктовДляМаршрута.Сортировать("Расстояние Возр");
	
	ПроверяемНаНаличиеДублейПунктов();	
	
	МинимальноеРасстояние = МинимальноеРасстояниеПоГраничным();
	
	Если МинимальноеРасстояние = Неопределено ТОгда
		
		Если НЕ ЗначениеЗаполнено(МинимальноеРасстояниеПоПостроеннымМаршрутам) Тогда
			Сообщить("Маршрут не найден");
		КОнецЕсли;
		
		Возврат;
	КонецЕсли;
	
	
	Если (ЗначениеЗаполнено(МинимальноеРасстояниеПоПостроеннымМаршрутам)
		И МинимальноеРасстояние < МинимальноеРасстояниеПоПостроеннымМаршрутам)
		ИЛИ НЕ ЗначениеЗаполнено(МинимальноеРасстояниеПоПостроеннымМаршрутам) Тогда
		
		ОтборПоМинимальномуРасстоянию = Новый Структура;
		ОтборПоМинимальномуРасстоянию.Вставить("ЯвляетсяГраничным", Истина);
		ОтборПоМинимальномуРасстоянию.Вставить("Расстояние", МинимальноеРасстояние);
		
		СтрокиСМинимальнымРасстоянием = ТаблицаИерархииПунктовДляМаршрута.НайтиСтроки(ОтборПоМинимальномуРасстоянию);
		ПерваяСтрокаСМинимальнымРасстоянием = СтрокиСМинимальнымРасстоянием[0];		
		
		//ЦиклПоВетке(МенеджерВременныхТаблиц, ТаблицаИерархииПунктовДляМаршрута,
		//ПерваяСтрокаСМинимальнымРасстоянием, МассивИсключенныхПунктов, НомерСтроки);
		ЦиклПоВетке(ПерваяСтрокаСМинимальнымРасстоянием, мНомерСтроки, сч);
		
	Иначе
		//дальше строить не имеет смыла. Найдено минимальное расстояние
		Возврат;
		
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
//Процедура ФормированиеСубВеток(МенеджерВременныхТаблиц, ТаблицаИерархииПунктовДляМаршрута,
//	Строка_ТаблицаИерархииПунктовДляМаршрута, МассивИсключенныхПунктов, НомерСтроки)
Процедура ФормированиеСубВеток(Строка_ТаблицаИерархииПунктовДляМаршрута, мНомерСтроки)
	
	
	//МассивИсключенныхПунктов.Добавить(Строка_ТаблицаИерархииПунктовДляМаршрута.Пункт);
	НайденныеСтроки = ТЗ_ПунктыДляСледующегоЭтапа.НайтиСтроки(новый Структура("ПунктСледования", Строка_ТаблицаИерархииПунктовДляМаршрута.Пункт));
	Для каждого НайденнаяСтрока Из НайденныеСтроки Цикл
		ТЗ_ПунктыДляСледующегоЭтапа.Удалить(НайденнаяСтрока);
	КонецЦикла;
	
	
	//Запрос = Новый Запрос;
	//Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	//Запрос.Текст = 
	//"ВЫБРАТЬ
	//|	ВТ_АктуальныеПунктыПоПроекту.ПунктОтправления КАК ПунктОтправления,
	//|	ВТ_АктуальныеПунктыПоПроекту.ПунктСледования КАК ПунктСледования,
	//|	ВТ_АктуальныеПунктыПоПроекту.Расстояние КАК Расстояние
	//|ПОМЕСТИТЬ ВТ
	//|ИЗ
	//|	ВТ_АктуальныеПунктыПоПроекту КАК ВТ_АктуальныеПунктыПоПроекту
	//|ГДЕ
	//|	НЕ ВТ_АктуальныеПунктыПоПроекту.ПунктСледования В (&МассивИсключенныхПунктов)
	//|;
	//|
	//|////////////////////////////////////////////////////////////////////////////////
	//|УНИЧТОЖИТЬ ВТ_АктуальныеПунктыПоПроекту
	//|;
	//|
	//|////////////////////////////////////////////////////////////////////////////////
	//|ВЫБРАТЬ
	//|	ВТ.ПунктОтправления КАК ПунктОтправления,
	//|	ВТ.ПунктСледования КАК ПунктСледования,
	//|	ВТ.Расстояние КАК Расстояние
	//|ПОМЕСТИТЬ ВТ_АктуальныеПунктыПоПроекту
	//|ИЗ
	//|	ВТ КАК ВТ
	//|;
	//|
	//|////////////////////////////////////////////////////////////////////////////////
	//|УНИЧТОЖИТЬ ВТ
	//|;
	//|
	//|////////////////////////////////////////////////////////////////////////////////
	//|ВЫБРАТЬ
	//|	ВТ_АктуальныеПунктыПоПроекту.ПунктОтправления КАК ПунктОтправления,
	//|	ВТ_АктуальныеПунктыПоПроекту.ПунктСледования КАК ПунктСледования,
	//|	ВТ_АктуальныеПунктыПоПроекту.Расстояние КАК Расстояние
	//|ИЗ
	//|	ВТ_АктуальныеПунктыПоПроекту КАК ВТ_АктуальныеПунктыПоПроекту
	//|ГДЕ
	//|	ВТ_АктуальныеПунктыПоПроекту.ПунктОтправления = &ПунктОтправления";
	//
	//Запрос.УстановитьПараметр("ПунктОтправления", Строка_ТаблицаИерархииПунктовДляМаршрута.Пункт);
	//Запрос.УстановитьПараметр("МассивИсключенныхПунктов", МассивИсключенныхПунктов);
	//РезультатЗапроса = Запрос.Выполнить();
	////ТЗ_ПунктыДляСледующегоЭтапа = РезультатЗапроса.Выгрузить();
	//СтрокаСледующегоЭтапа = РезультатЗапроса.Выбрать();
	
	НайденныеСтроки = ТЗ_ПунктыДляСледующегоЭтапа.НайтиСтроки(новый Структура("ПунктОтправления", Строка_ТаблицаИерархииПунктовДляМаршрута.Пункт));
	
	//Если ТЗ_ПунктыДляСледующегоЭтапа.Количество() = 0 ТОгда
	Если НайденныеСтроки.Количество() = 0 ТОгда
		Строка_ТаблицаИерархииПунктовДляМаршрута.Тупик = Истина;
		Строка_ТаблицаИерархииПунктовДляМаршрута.ЯвляетсяГраничным = Ложь;
		
		//можно удалить из ТаблицаИерархииПунктов
		
	КонецЕсли;
	
	//Для каждого СтрокаСледующегоЭтапа Из ТЗ_ПунктыДляСледующегоЭтапа Цикл
	Для каждого СтрокаСледующегоЭтапа Из НайденныеСтроки Цикл
		
		НоваяВетка = ТаблицаИерархииПунктовДляМаршрута.Добавить();
		НоваяВетка.НомерСтрокиРодителя =  Строка_ТаблицаИерархииПунктовДляМаршрута.мНомерСтроки;
		НоваяВетка.мНомерСтроки = мНомерСтроки;
		мНомерСтроки = мНомерСтроки + 1;
		
		НоваяВетка.Пункт = СтрокаСледующегоЭтапа.ПунктСледования;
		НоваяВетка.Расстояние = СтрокаСледующегоЭтапа.Расстояние + Строка_ТаблицаИерархииПунктовДляМаршрута.Расстояние;
		//НоваяВетка.РасстояниеДоКонечной = 0;
		НоваяВетка.Тупик = Ложь;
		НоваяВетка.НайденБолееОптимальныйМаршрутКДанномуПункту = Ложь;
		НоваяВетка.ЯвляетсяГраничным = Истина;
		НоваяВетка.Построен = Ложь;
		
		Если НоваяВетка.Пункт = ПунктСледования Тогда
			НоваяВетка.Построен = Истина;
			НоваяВетка.ЯвляетсяГраничным = ЛОжь;
			
			Если НЕ ЗначениеЗаполнено(МинимальноеРасстояниеПоПостроеннымМаршрутам) Тогда
				МинимальноеРасстояниеПоПостроеннымМаршрутам = НоваяВетка.Расстояние;
			ИначеЕсли МинимальноеРасстояниеПоПостроеннымМаршрутам > НоваяВетка.Расстояние Тогда
				МинимальноеРасстояниеПоПостроеннымМаршрутам = НоваяВетка.Расстояние
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	Строка_ТаблицаИерархииПунктовДляМаршрута.ЯвляетсяГраничным = Ложь;
	
КонецПроцедуры

&НаСервере
Функция МинимальноеРасстояниеПоГраничным()
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВнешняяТаблица.Расстояние КАК МинимальноеРасстояние,
	|	ВнешняяТаблица.ЯвляетсяГраничным КАК ЯвляетсяГраничным
	|ПОМЕСТИТЬ ВТ
	|ИЗ
	|	&ВнешняяТаблица КАК ВнешняяТаблица
	|ГДЕ
	|	ВнешняяТаблица.ЯвляетсяГраничным = ИСТИНА
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МИНИМУМ(ВТ.МинимальноеРасстояние) КАК МинимальноеРасстояние,
	|	ВТ.ЯвляетсяГраничным КАК ЯвляетсяГраничным
	|ИЗ
	|	ВТ КАК ВТ
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ.ЯвляетсяГраничным";
	
	Запрос.УстановитьПараметр("ВнешняяТаблица", ТаблицаИерархииПунктовДляМаршрута);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если Не РезультатЗапроса.Пустой() Тогда
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();  
		ВыборкаДетальныеЗаписи.Следующий();
		Возврат ВыборкаДетальныеЗаписи.МинимальноеРасстояние;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

&НаСервере
Процедура ПроверяемНаНаличиеДублейПунктов() 
	
	// Убить лишние ветки. Для каждого пункта не более одной ветки, оставляем с минимальным расстоянием
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВнешняяТаблица.Пункт КАК КонечныйПункт,
	|	ВнешняяТаблица.Расстояние КАК Расстояние,
	|	ВнешняяТаблица.ЯвляетсяГраничным КАК ЯвляетсяГраничным,
	|	ВнешняяТаблица.мНомерСтроки КАК мНомерСтроки
	|ПОМЕСТИТЬ ВТ_ПунктыИРасстояния
	|ИЗ
	|	&ВнешняяТаблица КАК ВнешняяТаблица
	|ГДЕ
	|	ВнешняяТаблица.ЯвляетсяГраничным = ИСТИНА
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ПунктыИРасстояния.КонечныйПункт КАК КонечныйПункт,
	|	МИНИМУМ(ВТ_ПунктыИРасстояния.Расстояние) КАК Расстояние,
	|	МИНИМУМ(ВТ_ПунктыИРасстояния.мНомерСтроки) КАК мНомерСтроки,
	|	МИНИМУМ(1) КАК ЭтотПунктОставляем
	|ПОМЕСТИТЬ ВТ_ПунктИМинимальноеРасстояние
	|ИЗ
	|	ВТ_ПунктыИРасстояния КАК ВТ_ПунктыИРасстояния
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ПунктыИРасстояния.КонечныйПункт
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ПунктыИРасстояния.КонечныйПункт КАК КонечныйПункт,
	|	ВТ_ПунктыИРасстояния.Расстояние КАК Расстояние,
	|	ВТ_ПунктыИРасстояния.мНомерСтроки КАК мНомерСтроки,
	|	ЕСТЬNULL(ВТ_ПунктИМинимальноеРасстояние.ЭтотПунктОставляем, 0) КАК ЭтотПунктОставляем
	|ИЗ
	|	ВТ_ПунктыИРасстояния КАК ВТ_ПунктыИРасстояния
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ПунктИМинимальноеРасстояние КАК ВТ_ПунктИМинимальноеРасстояние
	|		ПО (ВТ_ПунктИМинимальноеРасстояние.Расстояние = ВТ_ПунктыИРасстояния.Расстояние)
	|			И (ВТ_ПунктИМинимальноеРасстояние.КонечныйПункт = ВТ_ПунктыИРасстояния.КонечныйПункт)
	|			И (ВТ_ПунктыИРасстояния.мНомерСтроки = ВТ_ПунктИМинимальноеРасстояние.мНомерСтроки)
	|ГДЕ
	|	ЕСТЬNULL(ВТ_ПунктИМинимальноеРасстояние.ЭтотПунктОставляем, 0) = 0";
	
	Запрос.УстановитьПараметр("ВнешняяТаблица", ТаблицаИерархииПунктовДляМаршрута);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();  
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		Отбор_УбираемПризнакГраничный = Новый Структура;
		Отбор_УбираемПризнакГраничный.Вставить("мНомерСтроки", ВыборкаДетальныеЗаписи.мНомерСтроки);
		СтрокаТЗ = ТаблицаИерархииПунктовДляМаршрута.НайтиСтроки(Отбор_УбираемПризнакГраничный);
		
		СтрокаТЗ[0].ЯвляетсяГраничным = Ложь; 
		СтрокаТЗ[0].НайденБолееОптимальныйМаршрутКДанномуПункту = Истина;
	КонецЦикла;
	
	
КонецПроцедуры
	
#КонецОбласти 

#КонецЕсли
